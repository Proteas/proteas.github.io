---
layout: post
title:  Self QAï¼šCVE-2025-24203
date:   2025-05-21
categories: ios
---

## Q1: How does the `vm_object_t` hierarchy differ between `MAP_SHARED` and `MAP_PRIVATE`?

`vm_object_t` hierarchy of `MAP_SHARED`:<br/>
![MAP_SHARED](/assets/CVE-2025-24203-MAP_SHARED.svg)

`vm_object_t` hierarchy of `MAP_PRIVATE`:<br/>
![MAP_PRIVATE](/assets/CVE-2025-24203-MAP_PRIVATE.svg)

## Q2: How is memory data written back to the file?
In fact, the data in memory is not written back to the file.
```bash
sudo reboot
hexdump AAAAs.txt
```
You will see that the file content has not changed.<br/>

After `unwire_mlock_poc` exits, the `vnode_t` corresponding to `AAAAs.txt` is not released, will be reused, so modifications can take effect across processes.<br/>
It is currently unclear whether this is a memory leak or an intentional optimization.

## Q3: Why doesn't executing `munlock` first work?
Because the `zero_wired_pages` flag will be cleared.
```
file: osfmk/vm/vm_map.c
function: vm_map_unwire_nested

if (entry->zero_wired_pages) {
    entry->zero_wired_pages = FALSE;
}
```

## Q4: How was the vulnerability fixed?
Add permission checks.
```
ver: xnu-11417.101.15
file: osfmk/vm/vm_map.c
function: vm_map_behavior_set

if (new_behavior == VM_BEHAVIOR_ZERO_WIRED_PAGES) {
    /* zeroing requires write access */
    temp_entry = entry;
    // ...
}

ver: xnu-11417.101.15
file: osfmk/vm/vm_fault.c
function: vm_fault_unwire
if (entry->zero_wired_pages &&
    (entry->protection & VM_PROT_WRITE) &&
#if __arm64e__
    !entry->used_for_tpro &&
#endif /* __arm64e__ */
    !entry->used_for_jit) {
    pmap_zero_page(VM_PAGE_GET_PHYS_PAGE(result_page));
}
```

## Ref
 * https://project-zero.issues.chromium.org/issues/391518636
